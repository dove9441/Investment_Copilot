-- 1. 데이터베이스 초기화 및 설정
DROP DATABASE IF EXISTS AcademyManagement;
FLUSH TABLES;
CREATE DATABASE AcademyManagement;
USE AcademyManagement;
SET FOREIGN_KEY_CHECKS = 0;
SET SQL_MODE = 'NO_AUTO_VALUE_ON_ZERO';

-- 2. 기본 테이블 생성
CREATE TABLE Students (
   student_id INT AUTO_INCREMENT PRIMARY KEY,
   name VARCHAR(255) COLLATE utf8mb4_unicode_ci NOT NULL,
   phone_number VARCHAR(15) NOT NULL,
   is_new BOOLEAN DEFAULT TRUE,
   registration_date DATE NOT NULL,
   created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
   updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);
CREATE INDEX idx_student_registration ON Students(registration_date);

CREATE TABLE Classes (
   class_id INT AUTO_INCREMENT PRIMARY KEY,
   class_name VARCHAR(255) NOT NULL,
   day_of_week ENUM('토요일', '일요일') NOT NULL,
   time_slot VARCHAR(20) NOT NULL,
   is_active BOOLEAN DEFAULT TRUE,
   CONSTRAINT chk_class_name UNIQUE (class_name)
);
CREATE INDEX idx_class_active ON Classes(is_active);

CREATE TABLE ExamCategories (
   category_id INT AUTO_INCREMENT PRIMARY KEY,
   category_name VARCHAR(255) NOT NULL UNIQUE
);

CREATE TABLE ClassRounds (
   round_id INT AUTO_INCREMENT PRIMARY KEY,
   class_id INT NOT NULL,
   round_number INT NOT NULL,
   class_date DATE NOT NULL,
   status ENUM('SCHEDULED', 'COMPLETED', 'CANCELLED') DEFAULT 'SCHEDULED',
   CONSTRAINT fk_classround_class FOREIGN KEY (class_id) REFERENCES Classes(class_id) ON DELETE CASCADE,
   CONSTRAINT unq_class_round UNIQUE (class_id, round_number)
);
CREATE INDEX idx_class_date ON ClassRounds(class_date);

-- 3. 데이터 무결성 관련 트리거 생성
DELIMITER //

CREATE TRIGGER before_classround_insert
BEFORE INSERT ON ClassRounds
FOR EACH ROW
BEGIN
    IF NEW.round_number <= 0 THEN
        SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Round number must be positive';
    END IF;
END//

CREATE TRIGGER before_classround_update
BEFORE UPDATE ON ClassRounds
FOR EACH ROW
BEGIN
    IF NEW.round_number <= 0 THEN
        SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Round number must be positive';
    END IF;
END//

DELIMITER ;

-- 4. 나머지 테이블 생성
CREATE TABLE Class_Registration (
   registration_id INT AUTO_INCREMENT PRIMARY KEY,
   student_id INT NOT NULL,
   class_id INT NOT NULL,
   start_date DATE NOT NULL,
   is_active BOOLEAN DEFAULT TRUE,
   allows_makeup BOOLEAN DEFAULT TRUE,
   CONSTRAINT fk_registration_student FOREIGN KEY (student_id) REFERENCES Students(student_id) ON DELETE CASCADE,
   CONSTRAINT fk_registration_class FOREIGN KEY (class_id) REFERENCES Classes(class_id) ON DELETE CASCADE,
   CONSTRAINT unq_student_class UNIQUE (student_id, class_id)
);
CREATE INDEX idx_registration_active ON Class_Registration(is_active);

CREATE TABLE Attendance (
   attendance_id INT AUTO_INCREMENT PRIMARY KEY,
   student_id INT NOT NULL,
   round_id INT NOT NULL,
   original_class_id INT NOT NULL,
   is_present BOOLEAN DEFAULT FALSE,
   is_makeup BOOLEAN DEFAULT FALSE,
   absence_reason VARCHAR(255),
   CONSTRAINT fk_attendance_student FOREIGN KEY (student_id) REFERENCES Students(student_id) ON DELETE CASCADE,
   CONSTRAINT fk_attendance_round FOREIGN KEY (round_id) REFERENCES ClassRounds(round_id) ON DELETE CASCADE,
   CONSTRAINT fk_attendance_class FOREIGN KEY (original_class_id) REFERENCES Classes(class_id),
   CONSTRAINT unq_attendance UNIQUE (student_id, round_id)
);
CREATE INDEX idx_student_attendance ON Attendance(student_id, round_id);

CREATE TABLE Exams (
   exam_id INT AUTO_INCREMENT PRIMARY KEY,
   category_id INT NOT NULL,
   round_id INT NOT NULL,
   exam_name VARCHAR(255) NOT NULL,
   total_marks INT NOT NULL,
   exam_date DATE NOT NULL,
   CONSTRAINT fk_exam_category FOREIGN KEY (category_id) REFERENCES ExamCategories(category_id) ON DELETE CASCADE,
   CONSTRAINT fk_exam_round FOREIGN KEY (round_id) REFERENCES ClassRounds(round_id) ON DELETE CASCADE
);
CREATE INDEX idx_exam_date ON Exams(exam_date);

CREATE TABLE ExamAnswers (
   answer_id INT AUTO_INCREMENT PRIMARY KEY,
   student_id INT NOT NULL,
   exam_id INT NOT NULL,
   raw_answers TEXT NOT NULL,
   score INT NOT NULL,
   marking_date DATETIME NOT NULL,
   CONSTRAINT fk_examanswer_student FOREIGN KEY (student_id) REFERENCES Students(student_id) ON DELETE CASCADE,
   CONSTRAINT fk_examanswer_exam FOREIGN KEY (exam_id) REFERENCES Exams(exam_id) ON DELETE CASCADE,
   CONSTRAINT unq_student_exam UNIQUE (student_id, exam_id)
);
CREATE INDEX idx_exam_scores ON ExamAnswers(exam_id, score);

CREATE TABLE MessageTemplates (
   template_id INT AUTO_INCREMENT PRIMARY KEY,
   template_name VARCHAR(255) NOT NULL,
   base_content TEXT NOT NULL,
   message_type ENUM('ABSENT', 'EXAM_RESULT', 'NOTICE') NOT NULL
);

CREATE TABLE MessageGroups (
   group_id INT AUTO_INCREMENT PRIMARY KEY,
   round_id INT NOT NULL,
   group_name VARCHAR(255) NOT NULL,
   created_date DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
   CONSTRAINT fk_messagegroup_round FOREIGN KEY (round_id) REFERENCES ClassRounds(round_id) ON DELETE CASCADE
);
CREATE INDEX idx_message_group_date ON MessageGroups(created_date);

CREATE TABLE Messages (
   message_id INT AUTO_INCREMENT PRIMARY KEY,
   student_id INT NOT NULL,
   template_id INT NOT NULL,
   group_id INT NOT NULL,
   content TEXT NOT NULL,
   sent_date DATETIME NOT NULL,
   status ENUM('PENDING', 'SENT', 'FAILED') DEFAULT 'PENDING',
   CONSTRAINT fk_message_student FOREIGN KEY (student_id) REFERENCES Students(student_id) ON DELETE CASCADE,
   CONSTRAINT fk_message_template FOREIGN KEY (template_id) REFERENCES MessageTemplates(template_id) ON DELETE CASCADE,
   CONSTRAINT fk_message_group FOREIGN KEY (group_id) REFERENCES MessageGroups(group_id) ON DELETE CASCADE
);
CREATE INDEX idx_message_status ON Messages(status);
CREATE INDEX idx_message_date ON Messages(sent_date);

-- 5. 추가 트리거 생성
DELIMITER //

CREATE TRIGGER before_registration_insert 
BEFORE INSERT ON Class_Registration
FOR EACH ROW
BEGIN
   IF NEW.start_date < CURDATE() THEN
       SIGNAL SQLSTATE '45000'
       SET MESSAGE_TEXT = 'Start date must be greater than or equal to current date';
   END IF;
END//

CREATE TRIGGER before_exam_insert
BEFORE INSERT ON Exams
FOR EACH ROW
BEGIN
   IF NEW.exam_date < CURDATE() THEN
       SIGNAL SQLSTATE '45000'
       SET MESSAGE_TEXT = 'Exam date must be greater than or equal to current date';
   END IF;
END//

CREATE TRIGGER before_exam_answer_insert
BEFORE INSERT ON ExamAnswers
FOR EACH ROW
BEGIN
   DECLARE max_score INT;
   SELECT total_marks INTO max_score FROM Exams WHERE exam_id = NEW.exam_id;
   
   IF NEW.score > max_score THEN
       SIGNAL SQLSTATE '45000'
       SET MESSAGE_TEXT = 'Score cannot be greater than total marks';
   END IF;
   
   IF NEW.marking_date < NOW() THEN
       SIGNAL SQLSTATE '45000'
       SET MESSAGE_TEXT = 'Marking date must be greater than or equal to current timestamp';
   END IF;
END//

CREATE TRIGGER before_message_insert
BEFORE INSERT ON Messages
FOR EACH ROW
BEGIN
   IF NEW.sent_date < NOW() THEN 
       SIGNAL SQLSTATE '45000'
       SET MESSAGE_TEXT = 'Sent date must be greater than or equal to current timestamp';
   END IF;
END//

DELIMITER ;

-- 6. 외래키 체크 다시 활성화
SET FOREIGN_KEY_CHECKS = 1;



example 1의 내용을 참고해서 
나의 SQL코드를 분석
그리고 그 분석 결과를 이용해 

Design 그리고 각 기능을 나눠서 서술 할것 분량은 최대한 비슷하게 맞출 것 
너는 나한테 한국어로 출력 결과를 제시해야 하지만 
영어로 바꿨을 떄의 분량이 비슷해야 함

그리고 ER모델에 관한 설명이 납득 가능하게 만들어야 함 

그 다음은 3.2구현에 관한 내용 작성 

3.2.1처럼 Data strurcture creation을 작성 

그리고 3.2.2 작성 항상 비슷한 분량으로

그리고 3.2.3 작성 항상 비슷한 분량으로

3.2.4  작성 항상 비슷한 분량으로
3.2.4 테스트할 예시는 gpt에 제공해달라 하게 코드 분석하고 어떤식으로 명령 내릴 지 출력

그리고 4. evaluation에 관련된 내용 작성 
5.conclusion 작성 
6. reference 작성